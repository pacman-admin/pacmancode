// autogenerated by Processing revision 1292 on 2023-03-11

import processing.core.PApplet;
import processing.core.PImage;
import processing.sound.SoundFile;
// By Langdon S.
//import http.requests.*;


public class pac_man extends PApplet {
    // By Langdon S.
//current version:
    final float version = 10.10f;
    //______________________________________
//      G A M E  S E T T I N G S        |
//                                      |
    boolean startsWMouth = false; //        |
    int lives = 3; //                       |
    int chompSpeed = 8; //                 |
    boolean eyesMove = true; //             |
    boolean showGhostWhenStopped = true; // |
    boolean useOpenGL = false;//            |
    boolean other = false; //               |
    float ghostSpeed = 2; //                |
    float pacmanSpeed = 3; //               |
    boolean turnAround = true; //           |
    boolean playStartSound = true; //       |
    boolean playPauseBeat = true; //        |
//______________________________________|


    final static String TITLE = "Pac-Man ";

    //booleans
    boolean runSetup = true,
            first = false,
            first1 = true,
            doneFlash = true,
            paused = false,
            finishedDelay = false,
            pelletFirst = true,
            keyToggle = false,
            goodGhost1Dir = true,
            goodGhost2Dir = true,
            goodGhost3Dir = true,
            lostLife = false,
            startVal = true,
            startsuccess = false,
            start = true,
            updating = false,
            askUpdate = true;


    //Strings
    //String OS = "unknown";


    //ints
    int pelletWorth = 10, cellWidth = 32, startMillis,
            chomp = 30, canvasWidth = cellWidth * 13, canvasHeight = cellWidth * 13,
            level = 0, gsize = 2, lastScore = 0,
            pelletsEaten = 0, time = 0, pelletErrors = 0, cellCount = 0,
            highScore = 0, fruitWorth = 100, flashCount = 0, score = 0,
            livesClaimed = 0, duration = 0,
            frameCount1 = 0, startFrames = 1, durationStart = millis();


    int coordsX = 0, coordsY = 0,
            coords3X = 0, coords3Y = 0,
            coords4X = 0, coords4Y = 0,
            coords5X = 0, coords5Y = 0;

    int prevHighScore = 0;

    int[] livesOrder = {1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000};

    //String[] prevHighScoreStr;
    String[] messages = {};
    String[] fruitPoints = {
            "cherry",
            "strawberry",
            "orange",
            "orange",
            "apple",
            "apple",
            "melon",
            "melon",
            "galaxian",
            "galaxian",
            "bell",
            "bell",
            "key",
            "key"
    };

    float newVersion = 10.0f;
    float tempFPSVal = 0;
    float updateVersion = version;

    PImage cherry, strawberry, apple, orange, melon, galaxian, bell, keyI, restartB, noPauseBeatB;

    SoundFile dieS, startSound,
            dotSound1, dotSound2, fruit,
            extra_life, pause, pause_beat;

    Ghost ghost1 = new Ghost();
    Ghost ghost2 = new Ghost();
    Ghost ghost3 = new Ghost();

    Pacman pacman = new Pacman();

    Pellet[] pellet = {};
    Coordinate[] coords2 = {};

    Cell[][] cells = {new Cell[13], new Cell[13], new Cell[13],
            new Cell[13], new Cell[13], new Cell[13], new Cell[13],
            new Cell[13], new Cell[13], new Cell[13], new Cell[13],
            new Cell[13], new Cell[13]};

    Pixel[][] ghostPx = {new Pixel[16], new Pixel[16], new Pixel[16],
            new Pixel[16], new Pixel[16], new Pixel[16], new Pixel[16],
            new Pixel[16], new Pixel[16], new Pixel[16], new Pixel[16],
            new Pixel[16], new Pixel[16], new Pixel[16], new Pixel[16],
            new Pixel[16]};
    Pixel[][] ghostBottom2Px = {
            new Pixel[16], new Pixel[16]
    };


    int[][] gDesign = {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0},
            {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},
            {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},
            {0, 0, 1, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 0, 0},
            {0, 0, 1, 2, 3, 3, 2, 1, 1, 2, 3, 3, 2, 1, 0, 0},
            {0, 1, 1, 2, 3, 3, 2, 1, 1, 2, 3, 3, 2, 1, 1, 0},
            {0, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0},
            {0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0},
            {0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    };

    int[][] altGhostBottom = {
            {0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0},
            {0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0}
    };
    // Map layout
    int[] row1 = {0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int[] row2 = {0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1};
    int[] row3 = {0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1};
    int[] row4 = {0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1};
    int[] row5 = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int[] row6 = {0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1};
    int[] row7 = {0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1};
    int[] row8 = {0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1};
    int[] row9 = {0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1};
    int[] row10 = {0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1};
    int[] row11 = {0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1};


    public void settings() {
        if (useOpenGL) {
            size(canvasWidth, canvasHeight, P2D);
            smooth(8);
        } else {
            size(canvasWidth, canvasHeight);
        }
    }

    public void setup() {
        surface.setTitle("Loading...");
        println("Please wait...");
        noStroke();
        textSize(20);
        textAlign(CENTER);
        frameRate(120);
        fill(255);
        background(0);
        text("Loading...\nBy Langdon Staab", round(width / 2), round(height / 2));
        startMillis = millis();
        //check setup2() for setup
    }

    public void setup2() {
        noStroke();
        imageMode(CENTER);
        //chUpdateVersion(true);
        changeAppIcon();
        println(System.getProperty("os.name"));
        if (askUpdate) {
            //String temp = loadString("https://raw.githubusercontent.com/pacman-admin/pacmancode/main/myversion.txt");
            //newVersion = parseFloat(temp);
            println("Newest version", newVersion, "current version", version);
        } else {
            fill(255);
            background(0);
            text("Loading...\nBy Langdon Staab", round(width / 2), round(height / 2));
        }
        if (newVersion > updateVersion && askUpdate) {
            updating = true;
            askUpdate();
        } else {
            pause_beat = new SoundFile(this, "pause_beat.mp3");
            dieS = new SoundFile(this, "death.mp3");
            startSound = new SoundFile(this, "game_start.mp3");
            dotSound1 = new SoundFile(this, "dot_1.mp3");
            dotSound2 = new SoundFile(this, "dot_2.mp3");
            fruit = new SoundFile(this, "fruit.mp3");
            extra_life = new SoundFile(this, "extra_life.mp3");
            pause = new SoundFile(this, "pause.mp3");
            println("Sound load success!");

            prevHighScore = parseInt(loadString("highscore.txt"));
            println(prevHighScore);
            noPauseBeatB = loadImage("pause_beat off.png");
            cherry = loadImage("cherry.png");
            strawberry = loadImage("strawberry.png");
            orange = loadImage("orange.png");
            apple = loadImage("apple.png");
            melon = loadImage("melon.png");
            galaxian = loadImage("galaxian.png");
            bell = loadImage("bell.png");
            keyI = loadImage("key.png");
            restartB = loadImage("restart.png");
            println("Image load success!");
            createMaze();
            initializeMaze();
            makePelletCoords();
            pxInit();
            startMillis = millis();
            pellet[5].isFruit = true;
        }
        surface.setTitle(TITLE + version);

        println("Setup success!");
        //durationStart = millis();
    }


    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ A FEW RANDOM FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~///
    public String loadString(String filename) {
        println("Accessing content of", filename, "...");
        String[] ret;
        String data;
        try {
    /*
    loadString get = new loadString(URLPrefix+filename);
    get.send();
    String ret=get.getContent();*/
            ret = loadStrings(filename);
            data = ret[0];
            println("Success!", data);
            return data;
        } catch (Exception e) {
            println("Could not load information. Please check your internet connection.", e);
            return "error";
        }
    }



    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MAIN PROGRAM ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
    public void draw() {
        if (millis() - startMillis < 1000) {
            if (runSetup) {
                setup2();
                runSetup = false;
                startFrames = frameCount;
                //durationStart = millis();
                //println(duration);
                durationStart = millis();
                println(startVal);
                duration = 4500 + millis();
            }

        } else if (updating) {
            askUpdate();
        } else {
            if (frameCount % 2 == 0 && !paused) {
                if (millis() < duration) {
                    startsuccess = false;
                    pacman.stop();
                    pacman.stopped = true;
                    finishedDelay = false;
                    ghost1.halt();
                    ghost2.halt();
                    ghost3.halt();
                    startVal = true;
                    start = true;
                } else if (millis() <= duration + 100 && !finishedDelay) {
                    start = true;
                    ghost1.up();
                    ghost2.up();
                    ghost3.up();
                    finishedDelay = true;
                    startsuccess = true;
                } else if (!startsuccess) {
                    start = true;
                    ghost1.up();
                    ghost2.up();
                    ghost3.up();
                    finishedDelay = true;
                    startsuccess = true;
                }


                destroyUselessMessages();
                increaseHighScore();
                ghostPx[1][1].colourInit();
                coords3X = getGhostCoords(ghost1).x;
                coords3Y = getGhostCoords(ghost1).y;
                coords4X = getGhostCoords(ghost2).x;
                coords4Y = getGhostCoords(ghost2).y;
                coords5X = getGhostCoords(ghost3).x;
                coords5Y = getGhostCoords(ghost3).y;
                if (lostLife) {
                    if (chomp < 60) {
                        chomp++;
                    }
                    if (first1) {
                        frameCount1 = 1;
                        first1 = false;
                        delay(100);
                        if (chomp < 60) {
                            chomp = 60;
                        }
                        playSound(dieS);
                    }
                    pacman.stop();
                    ghost1.halt();
                    ghost2.halt();
                    ghost3.halt();
                    if (dieS.isPlaying()) {
                        chomp += 2;
                    } else {
                        ghost1.newgame();
                        ghost2.newgame();
                        ghost3.newgame();
                        pacman.x = cellWidth * 1.5f;
                        pacman.y = cellWidth * 1.5f;
                        first1 = true;
                        lostLife = false;
                        chomp = 16;
                        duration = 2000 + millis();
                        ghost1.up();
                        ghost2.up();
                        ghost3.up();
                        pacman.stop();
                        pacman.stopped = true;
                        lives--;
                    }
                }
                if (!pacman.dir.equals("stopped")) {
                    if (chomp > 60) {
                        chompSpeed = -chompSpeed;
                    }
                    if (chomp < 10) {
                        chompSpeed = -chompSpeed;
                    }
                    chomp += chompSpeed;
                }
                if (pelletsEaten < pellet.length - 1 && !lostLife) {
                    pacman.update();
                }
                ghost1.update(coords3X, coords3Y);
                ghost2.update(coords4X, coords4Y);
                ghost3.update(coords5X, coords5Y);
                ghost1.goodPosition(coords3X, coords3Y);
                ghost2.goodPosition(coords4X, coords4Y);
                ghost3.goodPosition(coords5X, coords5Y);
                controlGhostMovement(coords3X, coords3Y, coords4X, coords4Y, coords5X, coords5Y);
                moveGhosts();
                for (int b = 0; b < coords2.length; b++) {
                    pellet[b].goodPosition(coords2[b].x, coords2[b].y);
                    pellet[b].isBEaten();
                }
                background(0);
                showMaze(color(33, 33, 255), true);
                if (pelletsEaten >= pellet.length - 1 && !lostLife) {
                    if (!first) {
                        first = true;
                        frameCount1 = 0;
                        level++;
                        determineFruitType();
                        durationStart = millis();
                        println(startVal);
                        duration = 2000 + millis();
                    }
                    moveGhost1("stopped");
                    moveGhost2("stopped");
                    moveGhost3("stopped");
                    pacman.stop();
                    if ((millis() - durationStart < 250) || (millis() - durationStart < 750 && millis() - durationStart > 500) || (millis() - durationStart < 1250 && millis() - durationStart > 1000)
                            || (millis() - durationStart < 1750 && millis() - durationStart > 1500)) {
                        showMaze(color(222, 222, 255), true);
                        doneFlash = true;
                    }
                    if (millis() - durationStart >= 2000) {
                        determineFruitType();
                        pacman.update();
                        ghost1.up();
                        ghost2.up();
                        ghost3.up();
                        pacman.stopped = true;
                        pacman.stop();
                        makePelletCoords();
                        pelletErrors = 0;
                        flashCount = 0;
                        playStartSound = false;
                    }
                }


                if (lastScore != score) {
                    messages = splice(messages, "Your score is:" + str(score), 0);
                }
                display();

                start = false;
                lastScore = score;
            }

            if (keyPressed) {
                keyToggle = true;
                switch (keyCode) {
                    case UP -> pacman.up();
                    case DOWN -> pacman.down();
                    case RIGHT -> pacman.right();
                    case LEFT -> pacman.left();
                }
            }
            if (keyToggle) {
                switch (keyCode) {
                    case 87 -> pacman.up();
                    case 83 -> pacman.down();
                    case 68 -> pacman.right();
                    case 65 -> pacman.left();
                }
                if (keyCode != 0) {
                    keyToggle = false;
                }
            }
        }
    }

    public void display() {
        drawButtons();
        fill(255);
        textAlign(CENTER);
        textSize(12);
        text("HIGH SCORE\n" + highScore, 220, 12);

        makeTime();
        tempFPSVal = (time / 1000) > 0 ? (time / 1000) : 1;
        text(str(round((frameCount - startFrames) / tempFPSVal)), 330, 10);
        showLives();
        noStroke();
        for (int b = 0; b < coords2.length; b++) {
            pellet[b].draw();
        }
        drawGhosts();
        textAlign(LEFT);
        displayMessages();
        pacman.show(chomp);

        if (lives <= 0) {
            background(0);
            fill(255, 0, 0);
            textAlign(CENTER);
            text("GAME OVER", canvasWidth / 2, canvasHeight / 2);
            text("Click the screen to play again", canvasWidth / 2, canvasHeight / 2 + 40);
            if (mousePressed) {
                restart();
            }
        }
    }

    public void changeAppIcon() {
        getSurface().setIcon(loadImage("icon.png"));
    }

    public void displayMessages() {
        textSize(12);
        fill(0, 255, 50);
        for (int i = 0; i < messages.length; i++) {
            text(messages[i], 20, 20 + (i * 20));
        }
    }

    public void giveLives() {
        int w;
        if (score >= 1000) {
            w = round(score / 1000);
            for (int i = 0; i < livesOrder.length; i++) {
                if (w >= livesOrder[i]) {
                    if (livesClaimed < i + 1) {
                        lives++;
                        livesClaimed++;
                        playSound(extra_life);
                    }
                }
            }
        }
    }

    public void playSound(SoundFile sound) {
        sound.play();
    }

    public int createPosition(boolean dirIsX) {
        int newPos = round(random(cellWidth, canvasHeight - cellWidth * 2) / cellWidth) * cellWidth + cellWidth / 2;
        while (dirIsX && newPos <= cellWidth * 2.5) {
            newPos = round(random(cellWidth, canvasHeight - cellWidth * 2) / cellWidth) * cellWidth + cellWidth / 2;
        }
        return newPos;
    }

    public boolean hitBoxCollision(int cellX, int cellY, float objectX, float objectY) {
        return objectX > cellX && objectX < cellX + cellWidth && objectY > cellY && objectY < cellY + cellWidth;
    }

    public void makePelletCoords() {
        for (int i = 0; i < pellet.length; i++) {
            coords2[i].x = round((pellet[i].x) / cellWidth + 0.5f) - 1;
            coords2[i].y = round((pellet[i].y) / cellWidth + 0.5f) - 1;
        }
    }


//// OBJECTS \\\\

    static class Coordinate {
        int x = 0, y = 0;
    }


    // Cell \\
    class Cell {
        int x, y;
        boolean open/*, /*debug1*/;

        Cell(int x1, int y1) {
            x = x1;
            y = y1;
        }

        public void show(int colour, boolean all) {
            if (all) {
                if (!open) {
                    fill(colour);
                    rect(x, y, cellWidth, cellWidth);
                }
            } else {
                if (open) {
                    fill(0);
                    rect(x, y, cellWidth, cellWidth);
                }
            }
        }
    }


////// Calling Things //////

    public void pxInit() {
        for (int i = 0; i < ghostPx.length; i++) {
            for (int j = 0; j < ghostPx.length; j++) {
                ghostPx[i][j] = new Pixel(gDesign[i][j], gsize, j * gsize, i * gsize);
            }
        }
        for (int i = 0; i < altGhostBottom.length; i++) {
            for (int j = 0; j < altGhostBottom[0].length; j++) {
                ghostBottom2Px[i][j] = new Pixel(altGhostBottom[i][j], gsize, j * gsize, (i + 13) * gsize);
            }
        }
    }


//////// FUNCTIONS ////////

    public boolean checkGoodDir(String dir, int posX, int posY) {
        boolean goodDir = true;
        switch (dir) {
            case "up" -> {
                if (posY - 1 >= 0) {
                    goodDir = cells[posX][posY - 1].open;
                }
            }
            case "down" -> {
                if (posY + 1 <= height / cellWidth) {
                    goodDir = cells[posX][posY + 1].open;
                }
            }
            case "right" -> {
                if (posX + 1 <= width / cellWidth) {
                    goodDir = cells[posX + 1][posY].open;
                }
            }
            case "left" -> {
                if (posX - 1 >= 0) {
                    goodDir = cells[posX - 1][posY].open;
                }
            }
        }
        return !goodDir;
    }

    public String makeDir(int Var) {
        return switch (Var) {
            case 0 -> "up";
            case 1 -> "down";
            case 2 -> "right";
            case 3 -> "left";
            default -> "stopped";
        };
    }

    public int makeDirNum() {
        float tempDirNum = random(-0.1f, 4);
        int dirNum = floor(tempDirNum);
        dirNum = constrain(dirNum, 0, 3);
        return dirNum;
    }

    public void createMaze() {
        for (int i = 0; i < row1.length + 1; i++) {
            for (int j = 0; j < row1.length + 1; j++) {
                cells[i][j] = new Cell(i * cellWidth, j * cellWidth);
            }
        }
    }


    public void initializeMaze() {
        for (Cell[] cell : cells) {
            cell[0].open = false;
            cell[cells.length - 1].open = false;
        }
        for (int i = 0; i < cells[0].length; i++) {
            cells[0][i].open = false;
            cells[cells.length - 1][i].open = false;
        }
        for (int i = 0; i < row1.length; i++) {
            cells[i][1].open = PApplet.parseBoolean(row1[i]);
            if (cells[i][1].open) {
                if (i != 1) {
                    pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, cellWidth + cellWidth / 2));
                    coords2 = (Coordinate[]) append(coords2, new Coordinate());
                    cellCount++;
                }
            }

        }
        for (int i = 0; i < row2.length; i++) {
            cells[i][2].open = PApplet.parseBoolean(row2[i]);
            if (cells[i][2].open) {

                pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, 2 * cellWidth + cellWidth / 2));
                coords2 = (Coordinate[]) append(coords2, new Coordinate());
                cellCount++;
            }
        }
        for (int i = 0; i < row3.length; i++) {
            cells[i][3].open = PApplet.parseBoolean(row3[i]);
            if (cells[i][3].open) {
                cellCount++;
                pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, 3 * cellWidth + cellWidth / 2));
                coords2 = (Coordinate[]) append(coords2, new Coordinate());
            }
        }
        for (int i = 0; i < row4.length; i++) {
            cells[i][4].open = PApplet.parseBoolean(row4[i]);
            if (cells[i][4].open) {
                cellCount++;
                pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, 4 * cellWidth + cellWidth / 2));
                coords2 = (Coordinate[]) append(coords2, new Coordinate());
            }
        }
        for (int i = 0; i < row5.length; i++) {
            cells[i][5].open = PApplet.parseBoolean(row5[i]);
            if (cells[i][5].open) {
                cellCount++;
                pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, 5 * cellWidth + cellWidth / 2));
                coords2 = (Coordinate[]) append(coords2, new Coordinate());
            }
        }
        for (int i = 0; i < row6.length; i++) {
            cells[i][6].open = PApplet.parseBoolean(row6[i]);
            if (cells[i][6].open) {
                cellCount++;
                pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, 6 * cellWidth + cellWidth / 2));
                coords2 = (Coordinate[]) append(coords2, new Coordinate());
            }
        }
        for (int i = 0; i < row7.length; i++) {
            cells[i][7].open = PApplet.parseBoolean(row7[i]);
            if (cells[i][7].open) {
                cellCount++;
                pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, 7 * cellWidth + cellWidth / 2));
                coords2 = (Coordinate[]) append(coords2, new Coordinate());
            }
        }
        for (int i = 0; i < row8.length; i++) {
            cells[i][8].open = PApplet.parseBoolean(row8[i]);
            if (cells[i][8].open) {
                cellCount++;
                pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, 8 * cellWidth + cellWidth / 2));
                coords2 = (Coordinate[]) append(coords2, new Coordinate());
            }
        }
        for (int i = 0; i < row9.length; i++) {
            cells[i][9].open = PApplet.parseBoolean(row9[i]);
            if (cells[i][9].open) {
                cellCount++;
                pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, 9 * cellWidth + cellWidth / 2));
                coords2 = (Coordinate[]) append(coords2, new Coordinate());
            }
        }
        for (int i = 0; i < row10.length; i++) {
            cells[i][10].open = PApplet.parseBoolean(row10[i]);
            if (cells[i][10].open) {
                cellCount++;
                pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, 10 * cellWidth + cellWidth / 2));
                coords2 = (Coordinate[]) append(coords2, new Coordinate());
            }
        }
        for (int i = 0; i < row11.length; i++) {
            cells[i][11].open = PApplet.parseBoolean(row11[i]);
            if (cells[i][11].open) {
                cellCount++;
                pellet = (Pellet[]) append(pellet, new Pellet(i * cellWidth + cellWidth / 2, 11 * cellWidth + cellWidth / 2));
                coords2 = (Coordinate[]) append(coords2, new Coordinate());
            }
        }
    }

    public void showMaze(int mazeColor, boolean all) {
        for (Cell[] cell : cells) {
            for (Cell value : cell) {
                value.show(mazeColor, all);
            }
        }
    }


    public void destroyUselessMessages() {
        makeTime();
        while (messages.length > 6) {
            messages = shorten(messages);
        }
        if (time % 25 == 0 && time > 500 && messages.length > 0) {
            messages = shorten(messages);
        }
        if (messages.length > 4) {
            messages = shorten(messages);
        }
    }

    public void showLives() {
        float size = 20;
        float sizeT, sizeB;
        sizeT = map(size, 0, 60, 0, 0.52f);
        sizeB = map(size, 0, 60, TWO_PI, 5.76f);
        fill(255, 202, 0);
        for (int x = 1; x < lives; x++) {
            arc(25 * x, height - cellWidth / 2, 20, 20, sizeT, sizeB);
        }
    }

    public void increaseHighScore() {
        if (prevHighScore > highScore) {
            highScore = prevHighScore;
        }
        if (score > highScore) {

            highScore = score;
        }
        if (highScore > prevHighScore) {
            String[] newHighScore = {str(highScore)};
            saveStrings("highscore.txt", newHighScore);
        }

    }

    public void makeTime() {
        time = millis() - startMillis;
    }

    public void restart() {
        //durationStart = millis();
        lives = 3;
        lostLife = false;
        level = 0;
        playStartSound = true;
        makePelletCoords();
        pacman.update();
        pacman.x = cellWidth * 1.5f;
        pacman.y = cellWidth * 1.5f;
        score = 0;
        determineFruitType();
        startVal = true;
        startsuccess = false;
        for (Pellet value : pellet) {
            value.update();
        }
        durationStart = millis();
        println(startVal);
        duration = 4500 + millis();
    }

    public void restartButton() {
        int x = cellWidth * 4,
                y = cellWidth * 12;
        if (hitBoxCollision(x, y, mouseX, mouseY)) {
            restart();
        }
    }

    public void pauseButton(boolean drawButton) {
        int x = cellWidth * 5,
                y = cellWidth * 12;

        if (drawButton) {
            rect(x, y, cellWidth, cellWidth);
        }
        if (hitBoxCollision(x, y, mouseX, mouseY)) {
            if (paused) {
                if (pause_beat.isPlaying()) {
                    pause_beat.stop();
                }
            } else {
                pause.play();
                if (playPauseBeat) {
                    pause_beat.loop();
                }
            }

            delay(10);
            paused = !paused;
        }
    }

    public void pauseBeatOffButton() {
        int x = cellWidth * 3,
                y = cellWidth * 12;
        if (hitBoxCollision(x, y, mouseX, mouseY)) {
            playPauseBeat = !playPauseBeat;
            messages = splice(messages, "You have turned pause_beat " + (playPauseBeat ? "on" : "off"), 0);
        }
    }


    public void drawButtons() {
        image(restartB, cellWidth * 4 + cellWidth / 2, cellWidth * 12 + cellWidth / 2, cellWidth, cellWidth);
        image(noPauseBeatB, cellWidth * 3 + cellWidth / 2, cellWidth * 12 + cellWidth / 2, cellWidth, cellWidth);
        fill(0);
        rect(cellWidth * 5.2f, cellWidth * 12.1f, cellWidth / 4, cellWidth * 0.8f, 10);
        rect(cellWidth * 5.55f, cellWidth * 12.1f, cellWidth / 4, cellWidth * 0.8f, 10);
    }

    public void determineFruitType() {
        if (level < fruitPoints.length) {
            pellet[5].fruitType = fruitPoints[level];
        } else {
            pellet[5].fruitType = fruitPoints[fruitPoints.length - 1];
        }
    }


    public void mouseClicked() {
        if (!updating) {
            pauseBeatOffButton();
            restartButton();
            pauseButton(false);
        }
    }


    //// Pellet \\\\
    class Pellet {
        int x, y;
        boolean eaten = false, isFruit = false;
        String fruitType = "cherry";

        Pellet(int x1, int y1) {
            x = x1;
            y = y1;
        }

        public void update() {
            pelletsEaten = 0;
            eaten = false;
            if (isFruit) {
                fruitWorth = 100;
            }
        }

        public void isBEaten() {
            giveLives();
            if (!eaten && dist(x, y, pacman.x, pacman.y) < cellWidth / 8 + pacman.size / 8) {
                if (isFruit) {
                    switch (fruitType) {
                        case "cherry" -> fruitWorth = 100;
                        case "strawberry" -> fruitWorth = 300;
                        case "orange" -> fruitWorth = 500;
                        case "apple" -> fruitWorth = 700;
                        case "melon" -> fruitWorth = 1000;
                        case "galaxian" -> fruitWorth = 2000;
                        case "bell" -> fruitWorth = 3000;
                        case "key" -> fruitWorth = 5000;
                    }
                    score += fruitWorth;
                    playSound(fruit);
                } else {
                    if (!pelletFirst) {
                        playSound(dotSound2);
                        pelletFirst = true;
                    } else {
                        playSound(dotSound1);
                        pelletFirst = false;
                    }
                    score += pelletWorth;
                    pelletsEaten++;
                }
                eaten = true;
            }
        }

        public void draw() {
            if (!eaten) {
                noStroke();
                if (isFruit) {
                    switch (fruitType) {
                        case "strawberry" -> image(strawberry, x, y, 32, 32);
                        case "orange" -> image(orange, x, y, 32, 32);
                        case "apple" -> image(apple, x, y, 32, 32);
                        case "melon" -> image(melon, x, y, 32, 32);
                        case "galaxian" -> image(galaxian, x, y, 32, 32);
                        case "bell" -> image(bell, x, y, 32, 32);
                        case "key" -> image(keyI, x, y, 32, 32);
                        default -> image(cherry, x, y, 32, 32);
                    }
                } else {
                    noStroke();
                    fill(255, 150, 0);
                    ellipse(x, y, cellWidth / 2 - 1, cellWidth / 2 - 1);
                }
            }
        }

        public void goodPosition(int coordsX1, int coordsY1) {
            boolean a = false;
            if (coordsY1 == 1 && !isFruit) {
                if (coordsX1 == 1 || coordsX1 == 8) {
                    a = true;
                }
            }
            if (!cells[coordsX1][coordsY1].open || a) {
                update();
                x = createPosition(true);
                y = createPosition(false);
                while (dist(x, y, pacman.x, pacman.y) < cellWidth / 2) {
                    x = createPosition(true);
                    y = createPosition(false);
                }
                fill(255, 128, 255);
                ellipse(x, y, cellWidth / 2 - 1, cellWidth / 2 - 1);
                pelletErrors++;
                messages = splice(messages, "Adjustment in Progress...", 0);
                messages = splice(messages, str(pelletErrors) + "pellet(s) were misplaced", 0);
                makePelletCoords();
            }

            if (isFruit) {
                y = PApplet.parseInt(round(cellWidth * 1.5f));
            }
        }
    }

    class Ghost {
        float x, y;
        int size;
        boolean stopped;
        String dir;

        Ghost() {
            x = createPosition(true);
            y = createPosition(false);
            size = cellWidth;
            stopped = true;
            dir = "up";
        }

        public void update(int coordsX, int coordsY) {
            switch (dir) {
                case "up" -> {
                    if (coordsY - 1 >= 0) {
                        if (cells[coordsX][coordsY - 1].open) {
                            x = coordsX * cellWidth + (cellWidth / 2);
                            y -= ghostSpeed;
                        }
                    }
                }
                case "down" -> {
                    if (coordsY + 1 <= height / cellWidth) {
                        if (cells[coordsX][coordsY + 1].open) {
                            x = coordsX * cellWidth + (cellWidth / 2);
                            y += ghostSpeed;
                        }
                    }
                }
                case "right" -> {
                    if (coordsX + 1 <= width / cellWidth) {
                        if (cells[coordsX + 1][coordsY].open) {
                            y = coordsY * cellWidth + (cellWidth / 2);
                            x += ghostSpeed;
                        }
                    }
                }
                case "left" -> {
                    if (coordsX - 1 >= 0) {
                        if (cells[coordsX - 1][coordsY].open) {
                            y = coordsY * cellWidth + (cellWidth / 2);
                            x -= ghostSpeed;
                        } else {
                            fill(0, 255, 0);
                        }
                    }
                }
            }
            if (dist(x, y, pacman.x, pacman.y) < cellWidth / 2) {
                if (x >= cellWidth * 2) {
                    lostLife = true;
                }
            }
        }

        public void up() {
            dir = "up";
        }

        public void down() {
            dir = "down";
        }

        public void right() {
            dir = "right";
        }

        public void left() {
            dir = "left";
        }

        public void halt() {
            stopped = true;
            dir = "stopped";
        }

        public void newgame() {
            x = createPosition(true);
            y = createPosition(false);
        }
        public void goodPosition(int coordsX, int coordsY) {
            if (!cells[coordsX][coordsY].open) {
                newgame();
                messages = splice(messages, "Adjustment in Progress...", 0);
            }
            if (coordsX == 1) {
                right();
            }
            if (x > canvasWidth - cellWidth || x < cellWidth || y > canvasHeight - cellWidth || y < cellWidth) {
                messages = splice(messages, "Adjustment in Progress...", 0);
                newgame();
            }
        }
    }


    public Coordinate getGhostCoords(Ghost curGhost) {
        int a = 3, b = 1;
        float offsety = 0, offsetx = 0;
        Coordinate curGhostCoords = new Coordinate();
        switch (curGhost.dir) {
            case "up" -> offsety += cellWidth / a + b;
            case "down" -> offsety -= cellWidth / a + b;
            case "right" -> offsetx -= cellWidth / a + b;
            case "left" -> offsetx += cellWidth / a + b;
        }
        curGhostCoords.x = PApplet.parseInt(round((curGhost.x + offsetx) / cellWidth + 0.5f) - 1);
        curGhostCoords.y = PApplet.parseInt(round((curGhost.y + offsety) / cellWidth + 0.5f) - 1);
        return curGhostCoords;
    }


    public void drawGhostEyes(Ghost cGhost) {
        int x = 7;
        int y = 11;
        rectMode(CORNER);
        rectMode(CORNER);
        fill(63, 0, 252);
        if (eyesMove) {
            switch (cGhost.dir) {
                case "up" -> y -= 2;
                case "down" -> y += 2;
                case "right" -> x += 2;
                case "left" -> x -= 2;
            }
        }
        rect(x, y, 4, 4);
        rect(x + 12, y, 4, 4);
    }

    public void drawGhosts() {
        if (!ghost1.dir.equals("stopped") || showGhostWhenStopped) {
            translate(ghost1.x - 15, ghost1.y - 15);
            for (int i = 0; i < ghostPx.length; i++) {
                for (int j = 0; j < ghostPx.length; j++) {
                    if ((i == 14 || i == 13) && (frameCount - startFrames) % 100 < 45) {
                        ghostBottom2Px[i - 13][j].colourInit();
                        ghostBottom2Px[i - 13][j].draw(color(208, 62, 25));
                    } else {
                        ghostPx[i][j].colourInit();
                        ghostPx[i][j].draw(color(208, 62, 25));
                    }
                }
            }

            drawGhostEyes(ghost1);
            resetMatrix();
        }
        if (!ghost2.dir.equals("stopped") || showGhostWhenStopped) {
            translate(ghost2.x - 15, ghost2.y - 15);
            for (int i = 0; i < ghostPx.length; i++) {
                for (int j = 0; j < ghostPx.length; j++) {
                    if ((i == 14 || i == 13) && (frameCount - startFrames) % 100 < 45) {
                        ghostBottom2Px[i - 13][j].colourInit();
                        ghostBottom2Px[i - 13][j].draw(color(234, 130, 229));
                    } else {
                        ghostPx[i][j].colourInit();
                        ghostPx[i][j].draw(color(234, 130, 229));
                    }
                }
            }

            drawGhostEyes(ghost2);
            resetMatrix();
        }
        if (!ghost3.dir.equals("stopped") || showGhostWhenStopped) {
            translate(ghost3.x - 15, ghost3.y - 15);
            for (int i = 0; i < ghostPx.length; i++) {
                for (int j = 0; j < ghostPx.length; j++) {
                    if ((i == 14 || i == 13) && (frameCount - startFrames) % 100 < 45) {
                        ghostBottom2Px[i - 13][j].colourInit();
                        ghostBottom2Px[i - 13][j].draw(color(70, 191, 238));
                    } else {
                        ghostPx[i][j].colourInit();
                        ghostPx[i][j].draw(color(70, 191, 238));
                    }
                }
            }

            drawGhostEyes(ghost3);
            resetMatrix();

        }
    }

    public String createRDir(int posX, int posY) {
        int tempVar = round(random(3));
        String possDir = makeDir(tempVar);
        while (checkGoodDir(possDir, posX, posY)) {
            tempVar = makeDirNum();
            possDir = makeDir(tempVar);
        }

        return possDir;
    }

    public void moveGhost1(String dir) {
        switch (dir) {
            case "up" -> ghost1.up();
            case "down" -> ghost1.down();
            case "right" -> ghost1.right();
            case "left" -> ghost1.left();
            case "stopped" -> ghost1.halt();
        }
    }

    public void moveGhost2(String dir) {
        switch (dir) {
            case "up" -> ghost2.up();
            case "down" -> ghost2.down();
            case "right" -> ghost2.right();
            case "left" -> ghost2.left();
            case "stopped" -> ghost2.halt();
        }
    }

    public void moveGhost3(String dir) {
        switch (dir) {
            case "up" -> ghost3.up();
            case "down" -> ghost3.down();
            case "right" -> ghost3.right();
            case "left" -> ghost3.left();
            case "stopped" -> ghost3.halt();
        }
    }

    public void controlGhostMovement(int pos1x, int pos1y, int pos2x, int pos2y, int pos3x, int pos3y) {
        goodGhost1Dir = true;
        goodGhost2Dir = true;
        goodGhost3Dir = true;
        if (checkGoodDir(ghost1.dir, pos1x, pos1y)) {
            goodGhost1Dir = false;
        }
        if (checkGoodDir(ghost2.dir, pos2x, pos2y)) {
            goodGhost2Dir = false;
        }
        if (checkGoodDir(ghost3.dir, pos3x, pos3y)) {
            goodGhost3Dir = false;
        }
        if (!goodGhost1Dir) {
            ghost1.dir = createRDir(pos1x, pos1y);
        }
        if (!goodGhost2Dir) {
            ghost2.dir = createRDir(pos2x, pos2y);
        }
        if (!goodGhost3Dir) {
            ghost3.dir = createRDir(pos3x, pos3y);
        }
    }

    public void moveGhosts() {
        if (pelletsEaten < pellet.length - 1) {
            moveGhost1(ghost1.dir);
            moveGhost2(ghost2.dir);
            moveGhost3(ghost3.dir);
        }
    }
//// Pacman \\


    class Pacman {
        boolean stopped = true;

        int /*chompSpeed = 2, m = 1,
                mc = 0, */size = cellWidth - 1;

        float x = cellWidth / 2 + cellWidth,
                speed = pacmanSpeed,
                y = cellWidth / 2 + cellWidth;

        String nextDir = "stopped",
                dir = "stopped",
                lastDir = dir;


        public void show(float mouthSize) {
            float mouthOpenTop, mouthOpenBottom;
            if (Float.isNaN(mouthSize)) {
                mouthSize = 16;
            }
            if (stopped && !startsWMouth) {
                mouthSize = 0;
                if (playStartSound) {
                    playSound(startSound);
                    playStartSound = false;
                }
            }
            fill(255, 255, 0);
            translate(x, y);
            switch (lastDir) {
                case "up" -> rotate(PI + HALF_PI);
                case "down" -> rotate(HALF_PI);
                case "left" -> rotate(PI);
            }
            mouthOpenTop = map(mouthSize, 0, 60, 0, 0.52f);
            mouthOpenBottom = map(mouthSize, 0, 60, TWO_PI, 5.76f);
            arc(0, 0, 30, 30, mouthOpenTop, mouthOpenBottom);
            resetMatrix();
        }

        public void update() {
            float offsetx = 0.2f,
                    offsety = 0.1f,
                    a = 3, b = 1;
            //boolean waiting = false;
            
            switch (dir) {
                case "up" -> offsety += cellWidth / a + b;
                case "down" -> offsety -= cellWidth / a + b;
                case "right" -> offsetx -= cellWidth / a + b;
                case "left" -> offsetx += cellWidth / a + b;
            }

            coordsX = round((x + offsetx) / cellWidth + 0.5f) - 1;
            coordsY = round((y + offsety) / cellWidth + 0.5f) - 1;

            if (pelletsEaten >= pellet.length - 1) {
                for (Pellet value : pellet) {
                    value.update();
                }
                first = false;
                coordsX = 1;
                coordsY = 1;
                x = cellWidth * 1.5f;
                y = cellWidth * 1.5f;
                dir = "stopped";
                nextDir = "stopped";
                lastDir = "right";
            }

            switch (nextDir) {
                case "up" -> {
                    if (cells[parseInt(coordsX)][parseInt(coordsY) - 1].open) {
                        dir = nextDir;
                        x = coordsX * cellWidth + (cellWidth / 2);
                    } else {
                        if (other && !nextDir.equals(dir)) {
                            messages = splice(messages, "I want to move up", 0);
                        }
                    }
                }
                case "down" -> {
                    if (cells[parseInt(coordsX)][parseInt(coordsY) + 1].open) {
                        dir = nextDir;
                        x = coordsX * cellWidth + (cellWidth / 2);
                    } else {
                        if (other && !nextDir.equals(dir)) {
                            messages = splice(messages, "I want to move down", 0);
                        }
                    }
                }
                case "right" -> {
                    if (cells[parseInt(coordsX) + 1][parseInt(coordsY)].open) {
                        dir = nextDir;
                        y = coordsY * cellWidth + (cellWidth / 2);
                    } else {
                        if (other && !nextDir.equals(dir)) {
                            messages = splice(messages, "I want to move right", 0);
                        }
                    }
                }
                case "left" -> {
                    if (cells[parseInt(coordsX) - 1][parseInt(coordsY)].open) {
                        dir = nextDir;
                        y = coordsY * cellWidth + (cellWidth / 2);
                    } else {
                        if (other && !nextDir.equals(dir)) {
                            messages = splice(messages, "I want to move left", 0);
                        }
                    }
                }
            }

            switch (dir) {
                case "up" -> {
                    if (cells[parseInt(coordsX)][parseInt(coordsY) - 1].open) {
                        y -= speed;
                        stopped = false;
                        if (x < coordsX * cellWidth + (cellWidth / 2)) {
                            x++;
                        }
                        if (x > coordsX * cellWidth + (cellWidth / 2)) {
                            x--;
                        }
                        lastDir = "up";
                    } else {
                        dir = nextDir;
                        nextDir = "stopped";
                    }
                }
                case "down" -> {
                    if (cells[parseInt(coordsX)][parseInt(coordsY) + 1].open) {
                        y += speed;
                        stopped = false;
                        if (x < coordsX * cellWidth + (cellWidth / 2)) {
                            x++;
                        }
                        if (x > coordsX * cellWidth + (cellWidth / 2)) {
                            x--;
                        }
                        lastDir = "down";
                    } else {
                        dir = nextDir;
                        nextDir = "stopped";
                    }
                }
                case "right" -> {
                    if (cells[parseInt(coordsX) + 1][parseInt(coordsY)].open) {
                        x += speed;
                        stopped = false;
                        if (y < coordsY * cellWidth + (cellWidth / 2)) {
                            y++;
                        }
                        if (y > coordsY * cellWidth + (cellWidth / 2)) {
                            y--;
                        }
                        lastDir = "right";
                    } else {
                        dir = nextDir;
                        nextDir = "stopped";
                    }
                }
                case "left" -> {
                    if (cells[parseInt(coordsX) - 1][parseInt(coordsY)].open) {
                        x -= speed;
                        stopped = false;
                        if (y < coordsY * cellWidth + (cellWidth / 2)) {
                            y++;
                        }
                        if (y > coordsY * cellWidth + (cellWidth / 2)) {
                            y--;
                        }
                        lastDir = "left";
                    } else {
                        dir = nextDir;
                        nextDir = "stopped";
                    }
                }
                case "stopped" -> {
                    if (x < coordsX * cellWidth + (cellWidth / 2)) {
                        x++;
                    }
                    if (x > coordsX * cellWidth + (cellWidth / 2)) {
                        x--;
                    }
                    if (y < coordsY * cellWidth + (cellWidth / 2)) {
                        y++;
                    }
                    if (y > coordsY * cellWidth + (cellWidth / 2)) {
                        y--;
                    }
                }
            }
            fill(255, 0, 0);
            if (x > 400) {
                x = 0;
                y = cellWidth + size / 2;
            }
            coordsX = round((x + offsetx) / cellWidth + 0.5f) - 1;
            coordsY = round((y + offsety) / cellWidth + 0.5f) - 1;
        }

        public void up() {
            coordsX = round((x) / cellWidth + 0.5f) - 1;
            coordsY = round((y) / cellWidth + 0.5f) - 1;
            if (coordsX == 999) {
                messages = splice(messages, "no coordinates!", 0);
            } else {
                if (turnAround || !dir.equals("down")) {
                    if (cells[parseInt(coordsX)][parseInt(coordsY) - 1].open) {
                        dir = "up";
                        nextDir = "up";
                        if (x < coordsX * cellWidth + (cellWidth / 2)) {
                            x++;
                        }
                        if (x > coordsX * cellWidth + (cellWidth / 2)) {
                            x--;
                        }
                    } else {
                        nextDir = "up";
                    }
                }
            }
        }

        public void down() {
            coordsX = round((x) / cellWidth + 0.5f) - 1;
            coordsY = round((y) / cellWidth + 0.5f) - 1;
            if (coordsX == 999) {
                messages = splice(messages, "no coordinates!", 0);
            } else {
                if (turnAround || !dir.equals("up")) {
                    if (cells[parseInt(coordsX)][parseInt(coordsY) + 1].open) {
                        dir = "down";
                        nextDir = "down";
                        if (x < coordsX * cellWidth + (cellWidth / 2)) {
                            x++;
                        }
                        if (x > coordsX * cellWidth + (cellWidth / 2)) {
                            x--;
                        }
                    } else {
                        nextDir = "down";
                    }
                }
            }
        }

        public void right() {
            coordsX = round((x) / cellWidth + 0.5f) - 1;
            coordsY = round((y) / cellWidth + 0.5f) - 1;
            if (coordsX == 999) {
                messages = splice(messages, "no coordinates!", 0);
            } else {
                if (turnAround || !dir.equals("left")) {
                    if (cells[parseInt(coordsX) + 1][parseInt(coordsY)].open) {
                        dir = "right";
                        nextDir = "right";
                        if (y < coordsY * cellWidth + (cellWidth / 2)) {
                            y++;
                        }
                        if (y > coordsY * cellWidth + (cellWidth / 2)) {
                            y--;
                        }
                    } else {
                        nextDir = "right";
                    }
                }
            }
        }

        public void left() {
            coordsX = round((x) / cellWidth + 0.5f) - 1;
            coordsY = round((y) / cellWidth + 0.5f) - 1;
            if (coordsX == 999) {
                messages = splice(messages, "no coordinates!", 0);
            } else {
                if (turnAround || !dir.equals("right")) {
                    if (cells[parseInt(coordsX) - 1][parseInt(coordsY)].open) {
                        dir = "left";
                        nextDir = "left";
                        if (y < coordsY * cellWidth + (cellWidth / 2)) {
                            y++;
                        }
                        if (y > coordsY * cellWidth + (cellWidth / 2)) {
                            y--;
                        }
                    } else {
                        nextDir = "left";
                    }
                }
            }
        }

        public void stop() {
            dir = "stopped";
            stopped = false;
            nextDir = "stopped";
        }
    }

    class Pixel {
        int colourCode, size;
        float x, y;
        int colour;

        Pixel(int colourCode1, int size1, float x1, float y1) {
            colourCode = colourCode1;
            size = size1;
            x = x1;
            y = y1;
        }

        public void colourInit() {
            switch (colourCode) {
                case 999 -> colour = color(255, 128, 128);
                case 0 -> colour = color(255, 0);
                case 1 -> colour = color(255, 0, 0);
                case 2 -> colour = color(255);
                case 3 -> colour = color(255);
                default -> colour = color(255, 0, 0);
            }
        }

        public void draw(int gColour) {
            if (size == 999) {
                size = 1;
            }
            if (colourCode == 1) {
                colour = gColour;
            }

            rectMode(CENTER);
            fill(colour);
            rect(x, y, size, size);
            rectMode(CORNER);
        }
    }
    //public void chUpdateVersion(boolean mine) {
    //String a = str(mine ? version : newVersion)
    //println(a);
    //if(mine){
    //}else{
    //}
    //}
    public void askUpdate() {
        /*
        int[] c;
        fill(192, 224, 255);
        strokeWeight(2);
        background(4, 4, 32);
        c = drawUpButtons();
        if(mousePressed){
            println("Baloney9!");
        }
        if(mouseX > c[0]-(c[2]/2) && mouseX < c[0]+(c[2]/2)){
            if(mouseY > c[1]-(c[3]/2) && mouseY < c[1]+(c[3]/2)){
                println("Updating...");
                background(0);
                text("Updating...",width/2,height/2);
                //update();
                updating = false;
                askUpdate = false;
            }
        }
        if(mouseX > (width-c[0])-(c[2]/2) && mouseX < (width-c[0])+(c[2]/2)){
            println("Baloney3!");
            if(mouseY > c[1]-(c[4]/2) && mouseY < c[1]+(c[4]/2)){
                fill(255);
                background(0);
                text("Loading...\nBy Langdon Staab", round(width/2), round(height/2));
                startMillis = millis();
                updating = false;
                askUpdate = false;
                runSetup = true;
                startMillis = millis();
            }
        }*/
    }
    /*
    public void update(){
        //println("Updating...");
        //String[] tempString = loadStrings("os.txt");
        OS = tempString[0];
        println("a"+OS+"b");
        if(OS.equals("Mac")){
            //println("You are using MacOS.");
            try{
                byte[] newJAR = loadBytes("https://raw.githubusercontent.com/pacman-admin/pacmancode/main/pac_man.jar");
                saveBytes("Pac-Man.app/Contents/app/new.jar", newJAR);
                println("successfully saved new version!");
                launch("update.command");
                exit();
            }catch (Exception e){
                text(e.toString(),200,200);
            }
        }else if(OS.equals("Windows")){
            print("You are using Microsoft Windows.");
            try{
                byte[] newJAR = loadBytes("https://raw.githubusercontent.com/pacman-admin/pacmancode/main/pac_man.jar");
                saveBytes("app/new.jar", newJAR);
                launch("update.cmd");
            }catch (Exception e){
                println(e);
            }
        }else{
            println("error");
        }
    }
    public int[] drawUpButtons(){
        rectMode(CENTER);
        textAlign(CENTER, CENTER);
        int a = 100,
                b = 200,
                c = 2,
                bWidth = 180,
                bHeight1 = 60,
                bHeight2 = 40;
        int[] coords = {a, a+b, bWidth, bHeight1, bHeight2};
        fill(255, 64, 64);
        rect(a, a+b, bWidth, bHeight1, 10);
        rect(width-a, a+b, bWidth, bHeight2, 10);
        fill(192, 224, 255);
        text("Download update\n(recommended)", a, (a+b)-c);
        text("No, Start Pac-Man", width-a, (a+b)-c);
        return coords;
    }*/


    static public void main(String[] passedArgs) {
        String[] appletArgs = new String[]{"pac_man"};
        if (passedArgs != null) {
            PApplet.main(concat(appletArgs, passedArgs));
        } else {
            PApplet.main(appletArgs);
        }
    }
}