// autogenerated by Processing revision 1292 on 2023-03-11

import processing.core.PApplet;
import processing.core.PImage;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;

/**
 * @author Langdon S.
 */

@SuppressWarnings("StatementWithEmptyBody")
public final class pac_man extends PApplet {
    private static final int GHOST1_COLOUR = -3129831;
    private static final int GHOST2_COLOUR = -1408283;
    private static final int GHOST3_COLOUR = -12140562;
    private static final int MAZE_BLUE = -14605825;
    private static final int MAZE_WHITE = -2171137;
    private final static String TITLE = "Pac-Man 11";
    private final static int CELLWIDTH = 32;
    private final static int HALF_CELLWIDTH = 16;
    private final static int pelletWorth = 10;
    private final static int CANVAS_WIDTH = (CELLWIDTH * 13);
    private final static int CANVAS_HEIGHT = (CELLWIDTH * 13);
    private final static int gSize = 2;
    private final static Fruit[] FRUIT_POINTS = {Fruit.CHERRY, Fruit.STRAWBERRY, Fruit.ORANGE, Fruit.ORANGE, Fruit.APPLE, Fruit.APPLE, Fruit.MELON, Fruit.MELON, Fruit.GALAXIAN, Fruit.GALAXIAN, Fruit.BELL, Fruit.BELL, Fruit.KEY, Fruit.KEY};
    private final static byte[][] GHOST_DESIGN = {{0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0}, {0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0}, {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0}, {0, 1, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 0}, {0, 1, 2, 3, 3, 2, 1, 1, 2, 3, 3, 2, 1, 0}, {1, 1, 2, 3, 3, 2, 1, 1, 2, 3, 3, 2, 1, 1}, {1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, {1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1}, {0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0}};
    private final static int[][] GHOST_BOTTOM_DESIGN = {{1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1}, {1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1}};
    private final static boolean[][] MAP_DESIGN = {{true, false, true, true, true, true, true, true, true, true, true}, {true, true, true, false, false, false, false, false, false, false, true}, {true, false, true, true, true, true, true, true, true, false, true}, {true, false, true, false, false, false, false, false, true, false, true}, {true, true, true, true, true, true, true, true, true, true, true}, {true, false, true, false, true, false, false, true, false, true, true}, {true, false, true, false, true, false, true, true, false, true, true}, {true, false, true, true, true, true, false, true, false, false, true}, {true, false, false, false, true, false, false, true, false, true, true}, {true, true, true, true, true, true, false, true, false, true, true}, {true, true, false, false, false, true, true, true, false, true, true}};
    //Strings
    static String errorInfo; //                   |
    private final Ghost ghost1 = new Ghost();
    private final Ghost ghost2 = new Ghost();
    private final Ghost ghost3 = new Ghost();
    private final Pacman pacman = new Pacman();
    private final Cell[][] cells = {new Cell[13], new Cell[13], new Cell[13], new Cell[13], new Cell[13], new Cell[13], new Cell[13], new Cell[13], new Cell[13], new Cell[13], new Cell[13], new Cell[13], new Cell[13]};
    private final Pixel[][] ghostPx = {new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14], new Pixel[14]};
    private final Pixel[][] ghostBottom2Px = {new Pixel[14], new Pixel[14]};
    final private Pellet[] pellet = new Pellet[78];
    //private String[] messages = {};
    private final ArrayList<String> messages = new ArrayList<>();
    // By Langdon S.
    //current version:
    //private boolean checkForUpdates;
    private int lives = 3; //                             |
    private int chompSpeed = 8; //                        |
    private boolean playStartSound = true; //             |
    //booleans
    private boolean errorScreen;
    private boolean finishedDelay;
    //private boolean first;
    private boolean first1 = true;
    private boolean lostLife;
    private boolean paused;
    private boolean pelletFirst;
    private boolean runSetup = true;
    //private boolean start;
    private int startMillis;
    private int chomp = 30;
    //private int cellCount;
    private int duration;
    private int durationStart;
    private int fruitWorth;
    private int highScore;
    private int level;
    private int livesClaimed;
    // private int pelletErrors;
    private int pelletsEaten;
    private int score;
    private int startFrames;
    private int coordsX;
    private int coordsY;
    private int prevHighScore;
    private PImage cherry;
    private PImage strawberry;
    private PImage apple;
    private PImage orange;
    private PImage melon;
    private PImage galaxian;
    private PImage bell;
    private PImage keyI;
    private PImage restartB;
    private PImage SettingsB;
    private Sound dieS;
    private Sound startSound;
    private Sound dotSound1;
    private Sound dotSound2;
    private Sound fruit;
    private Sound extra_life;
    private Sound pause;
    private Sound pause_beat;
    // private Coordinate[] coords2 = {};


    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ A FEW RANDOM FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~///

    public static void main(String[] passedArgs) {
        String[] appletArgs = new String[]{"pac_man"};
        if (passedArgs != null) {
            PApplet.main(concat(appletArgs, passedArgs));
        } else {
            PApplet.main(appletArgs);
        }
    }

    private static boolean hitBoxCollision(int cellX, int cellY, float objectX, float objectY) {
        return objectX > cellX && objectX < cellX + CELLWIDTH && objectY > cellY && objectY < cellY + CELLWIDTH;
    }

    public void settings() {
        size(CANVAS_WIDTH, CANVAS_HEIGHT);
    }

    public void setup() {
        surface.setTitle("Loading...");
        System.out.println("Please wait...");
        background(0);
        noStroke();
        textSize(20);
        textAlign(CENTER, CENTER);
        fill(255);
        text("Loading...\nBy Langdon Staab\n\nSound manager by Tyler Tomas\n\nwww.langdonstaab.ca", Math.round(width / 2f), Math.round(height / 2f));
        frameRate(120);
        //frameRate(60);
        //check setup2() for setup
    }

    private void setup2() {
        noStroke();
        surface.setResizable(true);
        imageMode(CENTER);

        changeAppIcon();

        Settings.updatePath();

        String temp = loadString(Settings.path + "/highscore.txt");
        if (temp.equals("error")) {
            try {
                PrintWriter file = new PrintWriter(Settings.path + "/highscore.txt");
                file.println(0);
                file.close();
                prevHighScore = 0;
            } catch (FileNotFoundException e) {
                messages.add("An Error  occurred while creating high score file");
                System.err.println("An error occurred while creating the high score file.");
                Error.log(e);
                prevHighScore = 0;
                StringWriter sw = new StringWriter();
                PrintWriter pw = new PrintWriter(sw);
                e.printStackTrace(pw);
                errorInfo += sw.toString();
            }
        } else {
            prevHighScore = java.lang.Integer.parseInt(temp);
        }
        Settings.load();
        if (Settings.useOpenGL) {
            System.setProperty("sun.java2d.opengl", "True");
        }

        startSound = new Sound("game_start.wav");
        dotSound1 = new Sound("dot_1.wav");
        dotSound2 = new Sound("dot_2.wav");
        pause = new Sound("pause.wav");
        pause_beat = new Sound("pause_beat.wav");
        dieS = new Sound("death.wav");
        fruit = new Sound("fruit.wav");
        extra_life = new Sound("extra_life.wav");
        System.out.println("Sound load success!");

        cherry = loadImage("cherry.png");
        SettingsB = loadImage("Settings.png");
        restartB = loadImage("restart.png");
        strawberry = loadImage("strawberry.png");
        orange = loadImage("orange.png");
        apple = loadImage("apple.png");
        melon = loadImage("melon.png");
        System.out.println("Image load success!");

        createMaze();
        initializeMaze();
        //makePelletCoords();
        pxInit();
        startMillis = millis();
        pellet[5].isFruit = true;
        surface.setTitle(TITLE);
        //checkForUpdates = Settings.updateOnStart;
        System.out.println("Setup success!");
    }

    private String loadString(String filename) {
        String[] ret;
        String data;
        try {
            ret = loadStrings(filename);
            data = ret[0];
            return data;
        } catch (Exception ignored) {
            return "error";
        }
    }

    private void lazyLoad() {
        messages.add("Loading more fruit sprites...");
        galaxian = loadImage("galaxian.png");
        bell = loadImage("bell.png");
        keyI = loadImage("key.png");
        messages.add("All fruit sprites loaded successfully.");
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MAIN PROGRAM ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
    public void draw() {
        try {
            if (errorScreen) {
                background(0);
                textAlign(LEFT, CENTER);
                text(errorInfo, 4, height / 2f);
            } else if (runSetup) {
                setup2();
                runSetup = false;
                startFrames = frameCount;
                durationStart = millis();
                duration = 4500 + millis();
                startMillis = millis();
                System.out.println(millis());
            } else if (millis() < 2000) ;
                //display loading screen for a minimum of 2 seconds.
                //wait until 2 seconds have passed
            else if (lives <= 0) {
                background(0);
                fill(255, 64, 64);
                textAlign(CENTER);
                text("GAME OVER", CANVAS_WIDTH / 2f, CANVAS_HEIGHT / 2f);
                text("Click the screen to play again", CANVAS_WIDTH / 2f, CANVAS_HEIGHT / 2f + 40);
                text("By Langdon Staab\nwww.langdonstaab.ca", CANVAS_WIDTH / 2f, CANVAS_HEIGHT / 2f + 80);
                if (mousePressed) {
                    restart();
                }
            } else {
                /*if (checkForUpdates && millis() > 60000) {
                    checkForUpdates = false;
                    Settings.getNewVersion();
                    if (Settings.newVersion > Settings.myVersion) {
                        updatePrompt.create();
                    }
                }*/
                if (frameCount % 2 == 0 && !paused) {
                    if (millis() < duration) {
                        pacman.stop();
                        pacman.stopped = true;
                        finishedDelay = false;
                        ghost1.halt();
                        ghost2.halt();
                        ghost3.halt();
                    } else if (!finishedDelay) {
                        ghost1.up();
                        ghost2.up();
                        ghost3.up();
                        finishedDelay = true;
                    }

                    destroyUselessMessages();

                    if (lostLife) {
                        if (chomp < 60) {
                            chomp++;
                        }
                        if (first1) {
                            first1 = false;
                            dieS.play();
                        }
                        pacman.stop();
                        ghost1.halt();
                        ghost2.halt();
                        ghost3.halt();
                        if (dieS.isPlaying()) {
                            chomp += 3;
                        } else {
                            ghost1.newGame();
                            ghost2.newGame();
                            ghost3.newGame();
                            pacman.x = CELLWIDTH + HALF_CELLWIDTH;
                            pacman.y = CELLWIDTH + HALF_CELLWIDTH;
                            first1 = true;
                            lostLife = false;
                            chomp = 16;
                            duration = 2000 + millis();
                            pacman.stop();
                            pacman.stopped = true;
                            lives--;
                        }
                    }
                    if (!pacman.dir.equals(Dir.STOPPED)) {
                        if (chomp > 80) {
                            chompSpeed = -chompSpeed;
                        }
                        if (chomp < 8) {
                            chompSpeed = -chompSpeed;
                        }
                        chomp += chompSpeed;
                    }
                    if (pelletsEaten < pellet.length - 1 && !lostLife) {
                        pacman.update();
                    }
                    ghost1.update();
                    ghost2.update();
                    ghost3.update();
                    ghost1.goodPosition();
                    ghost2.goodPosition();
                    ghost3.goodPosition();

                    background(0);
                    showMaze(MAZE_BLUE);

                    if (pelletsEaten >= pellet.length - 1 && !lostLife) {
                        ghost1.halt();
                        ghost2.halt();
                        ghost3.halt();
                        pacman.stop();
                        if ((millis() - durationStart < 250) || (millis() - durationStart < 750 && millis() - durationStart > 500) || (millis() - durationStart < 1250 && millis() - durationStart > 1000) || (millis() - durationStart < 1750 && millis() - durationStart > 1500)) {
                            showMaze(MAZE_WHITE);
                        }
                        if (millis() - durationStart >= 2000) {
                            //determineFruitType();
                            pacman.update();
                            ghost1.up();
                            ghost2.up();
                            ghost3.up();
                            pacman.stopped = true;
                            pacman.stop();
                            playStartSound = false;
                        }
                    }
                    display();
                    //int useless = 5 / 0;
                }
                if (keyPressed) {
                    switch (keyCode) {
                        case UP, 87 -> pacman.up();
                        case DOWN, 83 -> pacman.down();
                        case RIGHT, 68 -> pacman.right();
                        case LEFT, 65 -> pacman.left();
                    }

                }
            }
        } catch (Exception e) {
            paused = true;
            Error.save(e);

            errorScreen = true;
            textSize(12);
            fill(255);
            windowResize(1000, CANVAS_HEIGHT);
            frameRate(30);
            Error.log(e);

        }
    }

    private void display() throws FileNotFoundException {
        /*if (frameCount % 20 == 0) {
            System.out.println();
        }*/
        drawButtons();
        fill(255);
        textAlign(CENTER);
        textSize(12);
        text("HIGH SCORE\n" + highScore, width / 2f, 12);
        float tempFPSVal = ((millis() - startMillis) / 1000f) > 0 ? ((millis() - startMillis) / 1000f) : 1;
        text(str(Math.round((frameCount - startFrames) / tempFPSVal)), 330, 10);
        showLives();
        noStroke();
        for (Pellet value : pellet) {
            value.isBEaten();
            value.draw();
        }
        drawGhosts();
        textAlign(LEFT);
        displayMessages();
        pacman.show(chomp);
    }

    private void changeAppIcon() {
        getSurface().setIcon(loadImage("icon.png"));
    }

    private void displayMessages() {
        textSize(12);
        fill(0, 255, 50);
        for (int i = (messages.size() - 1); i >= 0; i--) {
            text(messages.get(i), 20, 20 + (i * 20));
        }
    }

    private void addLife() {
        lives++;
        livesClaimed++;
        extra_life.play();
        messages.add("Claimed extra life!");
    }

    private void giveLives() {
        if (score >= 1000 && livesClaimed < 1) {
            addLife();
        } else if (score >= 2000 && livesClaimed < 2) {
            addLife();
        } else if (score >= 5000 && livesClaimed < 3) {
            addLife();
        } else if (score >= 10000 && livesClaimed < 4) {
            addLife();
        } else if (score >= 20000 && livesClaimed < 5) {
            addLife();
        } else if (score >= 50000 && livesClaimed < 6) {
            addLife();
        } else if (score >= 100000 && livesClaimed < 7) {
            addLife();
        } else if (score >= 200000 && livesClaimed < 8) {
            addLife();
        } else if (score >= 500000 && livesClaimed < 9) {
            addLife();
        } else if (score >= 1000000 && livesClaimed < 10) {
            addLife();
        }
    }

    private int createPosition(boolean dirIsX) {
        int newPos = (Math.round(random(CELLWIDTH, CANVAS_HEIGHT - CELLWIDTH * 2f) / CELLWIDTH) * CELLWIDTH + HALF_CELLWIDTH);
        while (dirIsX && newPos <= (CELLWIDTH * 2) + HALF_CELLWIDTH) {
            newPos = (Math.round(random(CELLWIDTH, CANVAS_HEIGHT - CELLWIDTH * 2f) / CELLWIDTH) * CELLWIDTH + HALF_CELLWIDTH);
        }
        return newPos;
    }

    private void pxInit() {
        for (int i = 1; i < ghostPx.length + 1; i++) {
            for (int j = 1; j < ghostPx.length + 1; j++) {
                //println(GHOST_DESIGN[i][j] + ", " + i + ", " + j);
                ghostPx[i - 1][j - 1] = new Pixel(GHOST_DESIGN[i - 1][j - 1], j * gSize, i * gSize);
                ghostPx[i - 1][j - 1].colourInit();
            }
        }
        for (int i = 0; i < GHOST_BOTTOM_DESIGN.length; i++) {
            for (int j = 1; j < GHOST_BOTTOM_DESIGN[0].length + 1; j++) {
                ghostBottom2Px[i][j - 1] = new Pixel(GHOST_BOTTOM_DESIGN[i][j - 1], j * gSize, (i + 13) * gSize);
                ghostBottom2Px[i][j - 1].colourInit();
            }
        }
    }


////// Calling Things //////

    private boolean checkGoodDir(Dir dir, int posX, int posY) {
        boolean goodDir = true;
        switch (dir) {
            case Dir.UP -> {
                if (posY - 1 >= 0) {
                    goodDir = cells[posX][posY - 1].open;
                }
            }
            case Dir.DOWN -> {
                if (posY + 1 <= height / CELLWIDTH) {
                    goodDir = cells[posX][posY + 1].open;
                }
            }
            case Dir.RIGHT -> {
                if (posX + 1 <= width / CELLWIDTH) {
                    goodDir = cells[posX + 1][posY].open;
                }
            }
            case Dir.LEFT -> {
                if (posX - 1 >= 0) {
                    goodDir = cells[posX - 1][posY].open;
                }
            }
        }
        return !goodDir;
    }


//////// FUNCTIONS ////////

    private Dir makeDir(int Var) {
        return switch (Var) {
            case 0 -> Dir.UP;
            case 1 -> Dir.DOWN;
            case 2 -> Dir.RIGHT;
            case 3 -> Dir.LEFT;
            default -> Dir.STOPPED;
        };
    }

    private int makeDirNum() {
        float tempDirNum = random(-0.1f, 4);
        int dirNum = floor(tempDirNum);
        dirNum = constrain(dirNum, 0, 3);
        return dirNum;
    }

    private void createMaze() {
        for (int i = 0; i < MAP_DESIGN[1].length + 2; i++) {
            for (int j = 0; j < MAP_DESIGN[1].length + 2; j++) {
                cells[i][j] = new Cell(i * CELLWIDTH, j * CELLWIDTH);
            }
        }
    }

    private void initializeMaze() {
        int cellCount = 0;
        for (int row = 1; row < MAP_DESIGN[1].length + 1; row++) {
            for (int col = 1; col < MAP_DESIGN[1].length + 1; col++) {
                cells[col][row].open = MAP_DESIGN[row - 1][col - 1];
                if (MAP_DESIGN[row - 1][col - 1]) {
                    if (col > 1 || row > 1) {
                        // } else {
                        pellet[cellCount] = new Pellet(col * CELLWIDTH + HALF_CELLWIDTH, row * CELLWIDTH + HALF_CELLWIDTH);
                        //coords2 = (Coordinate[]) append(coords2, new Coordinate());
                        cellCount++;
                    }
                }
            }
        }
        println(cellCount);
    }

    private void showMaze(int mazeColor) {
        for (Cell[] cell : cells) {
            for (Cell value : cell) {
                value.show(mazeColor);
            }
        }
    }

    private void destroyUselessMessages() {
        while (messages.size() > 6) {
            messages.removeFirst();
        }
        if (millis() % 25 == 0 && (millis() - startMillis) > 500 && !messages.isEmpty()) {
            messages.removeFirst();
        }
        if (messages.size() > 4) {
            messages.removeFirst();
        }
    }

    private void showLives() {
        int size = 20;
        float sizeT, sizeB;
        sizeT = map(size, 0, 60, 0, 0.52f);
        sizeB = map(size, 0, 60, TWO_PI, 5.76f);
        fill(255, 202, 0);
        for (int x = 1; x < lives; x++) {
            arc(25 * x, height - HALF_CELLWIDTH, 20, 20, sizeT, sizeB);
        }
    }

    private void increaseHighScore() throws FileNotFoundException {
        if (prevHighScore > highScore) {
            highScore = prevHighScore;
        }
        if (score > highScore) {
            highScore = score;
        }
        if (highScore > prevHighScore) {
            PrintWriter out = new PrintWriter(Settings.path + "/highscore.txt");
            out.println(str(highScore));
            out.close();
        }
    }

    private void restart() {
        lives = 3;
        lostLife = false;
        level = 0;
        playStartSound = true;
        //makePelletCoords();
        pacman.update();
        pacman.x = CELLWIDTH + HALF_CELLWIDTH;
        pacman.y = CELLWIDTH + HALF_CELLWIDTH;
        score = 0;
        determineFruitType();
        for (Pellet value : pellet) {
            value.update();
        }
        durationStart = millis();
        duration = 4500 + millis();
    }

    private void restartButton() {
        int x = CELLWIDTH * 4, y = CELLWIDTH * 12;
        if (hitBoxCollision(x, y, mouseX, mouseY)) {
            restart();
        }
    }

    private void pauseButton() {
        int x = CELLWIDTH * 5, y = CELLWIDTH * 12;
        if (hitBoxCollision(x, y, mouseX, mouseY)) {
            if (paused) {
                pause_beat.stop();

            } else {
                pause.play();
                if (Settings.playPauseBeat) {
                    pause_beat.rewind();
                    pause_beat.loop();
                }
            }
            delay(10);
            paused = !paused;
        }
    }

    private void pauseBeatOffButton() {
        int x = CELLWIDTH * 3, y = CELLWIDTH * 12;
        if (hitBoxCollision(x, y, mouseX, mouseY)) {
            SettingsWindow.create();
        }
    }

    private void drawButtons() {
        image(restartB, CELLWIDTH * 4 + HALF_CELLWIDTH, CELLWIDTH * 12 + HALF_CELLWIDTH, CELLWIDTH - 4, CELLWIDTH - 4);

        image(SettingsB, CELLWIDTH * 3 + HALF_CELLWIDTH, CELLWIDTH * 12 + HALF_CELLWIDTH, CELLWIDTH - 4, CELLWIDTH - 4);
        fill(0);
        rect(CELLWIDTH * 5.2f, CELLWIDTH * 12.1f, CELLWIDTH / 4f, CELLWIDTH * 0.8f, 10);
        rect(CELLWIDTH * 5.55f, CELLWIDTH * 12.1f, CELLWIDTH / 4f, CELLWIDTH * 0.8f, 10);
    }

    private void determineFruitType() {
        if (level == 8) {
            //println(FRUIT_POINTS[level]);
            lazyLoad();
        }
        if (level < FRUIT_POINTS.length) {
            pellet[5].fruitType = FRUIT_POINTS[level];
        } else {
            pellet[5].fruitType = FRUIT_POINTS[FRUIT_POINTS.length - 1];
        }
    }

    public void mouseClicked() {
        //if (!updating) {
        pauseBeatOffButton();
        restartButton();
        pauseButton();
        // }
    }

    private void drawGhostEyes(Ghost cGhost) {
        int x = 7;
        int y = 11;
        rectMode(CORNER);
        rectMode(CORNER);
        fill(63, 0, 252);
        switch (cGhost.dir) {
            case Dir.UP -> y -= 2;
            case Dir.DOWN -> y += 2;
            case Dir.RIGHT -> x += 2;
            case Dir.LEFT -> x -= 2;
        }
        rect(x, y, 4, 4);
        rect(x + 12, y, 4, 4);
    }

    private void drawGhosts() {

        if (!ghost1.dir.equals(Dir.STOPPED) || Settings.showGhostWhenStopped) {
            translate(ghost1.x - 15, ghost1.y - 15);
            for (int i = 0; i < ghostPx.length; i++) {
                for (int j = 0; j < ghostPx.length; j++) {
                    if ((i >= 12) && (frameCount - startFrames) % 100 < 45) {
                        //ghostBottom2Px[i - 13][j].colourInit();
                        ghostBottom2Px[i - 12][j].draw(GHOST1_COLOUR);
                    } else {
                        //ghostPx[i][j].colourInit();
                        ghostPx[i][j].draw(GHOST1_COLOUR);
                    }
                }
            }
            drawGhostEyes(ghost1);
            resetMatrix();
        }
        if (!ghost2.dir.equals(Dir.STOPPED) || Settings.showGhostWhenStopped) {
            translate(ghost2.x - 15, ghost2.y - 15);
            for (int i = 0; i < ghostPx.length; i++) {
                for (int j = 0; j < ghostPx.length; j++) {
                    if ((i >= 12) && (frameCount - startFrames) % 100 < 45) {
                        //ghostBottom2Px[i - 13][j].colourInit();
                        ghostBottom2Px[i - 12][j].draw(GHOST2_COLOUR);
                    } else {
                        //ghostPx[i][j].colourInit();
                        ghostPx[i][j].draw(GHOST2_COLOUR);
                    }
                }
            }
            drawGhostEyes(ghost2);
            resetMatrix();
        }
        if (!ghost3.dir.equals(Dir.STOPPED) || Settings.showGhostWhenStopped) {
            translate(ghost3.x - 15, ghost3.y - 15);
            for (int i = 0; i < ghostPx.length; i++) {
                for (int j = 0; j < ghostPx.length; j++) {
                    if ((i >= 12) && (frameCount - startFrames) % 100 < 45) {
                        //ghostBottom2Px[i - 13][j].colourInit();
                        ghostBottom2Px[i - 12][j].draw(GHOST3_COLOUR);
                    } else {
                        //ghostPx[i][j].colourInit();
                        ghostPx[i][j].draw(GHOST3_COLOUR);
                    }
                }
            }
            drawGhostEyes(ghost3);
            resetMatrix();
        }
    }

    private Dir createRDir(int posX, int posY) {
        int tempVar = Math.round(random(3));
        Dir possDir = makeDir(tempVar);
        while (checkGoodDir(possDir, posX, posY)) {
            tempVar = makeDirNum();
            possDir = makeDir(tempVar);
        }
        return possDir;
    }

    //// OBJECTS \\\\
    private final class Ghost {
        int coordsX, coordsY;
        private int x;
        private int y;
        private Dir dir;

        private Ghost() {
            x = createPosition(true);
            y = createPosition(false);
            dir = Dir.UP;
        }

        private void updateCoords() {
            final int a = 3, b = 1;
            float offsetY = 0, offsetX = 0;
            switch (dir) {
                case Dir.UP -> offsetY += (float) (CELLWIDTH / a) + b;
                case Dir.DOWN -> offsetY -= ((float) (CELLWIDTH / a)) + b;
                case Dir.RIGHT -> offsetX -= (float) (CELLWIDTH / a) + b;
                case Dir.LEFT -> offsetX += (float) (CELLWIDTH / a) + b;
            }
            coordsX = Math.round((x + offsetX) / CELLWIDTH + 0.5f) - 1;
            coordsY = Math.round((y + offsetY) / CELLWIDTH + 0.5f) - 1;
        }

        private void update() {
            updateCoords();
            switch (dir) {
                case Dir.UP -> {
                    if (coordsY - 1 >= 0 && cells[coordsX][coordsY - 1].open) {
                        x = coordsX * CELLWIDTH + (HALF_CELLWIDTH);
                        y -= Settings.ghostSpeed;
                    } else {
                        dir = createRDir(coordsX, coordsY);
                    }
                }
                case Dir.DOWN -> {
                    if (coordsY + 1 <= height / CELLWIDTH && cells[coordsX][coordsY + 1].open) {
                        x = coordsX * CELLWIDTH + (HALF_CELLWIDTH);
                        y += Settings.ghostSpeed;
                    } else {
                        dir = createRDir(coordsX, coordsY);
                    }
                }
                case Dir.RIGHT -> {
                    if (coordsX + 1 <= width / CELLWIDTH && cells[coordsX + 1][coordsY].open) {
                        y = coordsY * CELLWIDTH + (HALF_CELLWIDTH);
                        x += Settings.ghostSpeed;
                    } else {
                        dir = createRDir(coordsX, coordsY);
                    }
                }
                case Dir.LEFT -> {
                    if (coordsX - 1 >= 0 && cells[coordsX - 1][coordsY].open) {
                        y = coordsY * CELLWIDTH + (HALF_CELLWIDTH);
                        x -= Settings.ghostSpeed;
                    } else {
                        dir = createRDir(coordsX, coordsY);
                    }
                }
            }
            if (dist(x, y, pacman.x, pacman.y) < HALF_CELLWIDTH) {
                if (x >= CELLWIDTH * 2) {
                    lostLife = true;
                }
            }
        }

        private void up() {
            dir = Dir.UP;
        }

        private void right() {
            dir = Dir.RIGHT;
        }

        private void halt() {
            //stopped = true;
            dir = Dir.STOPPED;
        }

        private void newGame() {
            x = createPosition(true);
            y = createPosition(false);
        }

        private void goodPosition() {
            updateCoords();
            if (!cells[coordsX][coordsY].open) {
                newGame();
                messages.add("Adjustment in Progress...");
            }
            if (coordsX == 1) {
                right();
            }
            if (x > CANVAS_WIDTH - CELLWIDTH || x < CELLWIDTH || y > CANVAS_HEIGHT - CELLWIDTH || y < CELLWIDTH) {
                messages.add("Adjustment in Progress...");
                newGame();
            }
        }
    }

    // Cell \\
    final class Cell {
        private final int x;
        private final int y;
        boolean open;

        private Cell(int x1, int y1) {
            x = x1;
            y = y1;
        }

        private void show(int colour) {

            if (!open) {
                fill(colour);
                rect(x, y, CELLWIDTH, CELLWIDTH);
            }

        }
    }

    //// Pellet \\\\
    final class Pellet {
        final private int x;
        final private int y;
        private boolean eaten = false;
        private boolean isFruit = false;
        private Fruit fruitType = Fruit.CHERRY;

        private Pellet(int x1, int y1) {
            x = x1;
            y = y1;
        }

        void update() {
            //pelletsEaten = 0;
            eaten = false;
            if (isFruit) {
                fruitWorth = 100;
            }
        }

        private void isBEaten() throws FileNotFoundException {
            if (!eaten && dist(x, y, pacman.x, pacman.y) < CELLWIDTH / 8f + Pacman.size / 8f) {
                if (isFruit) {
                    switch (fruitType) {
                        case Fruit.CHERRY -> fruitWorth = 100;
                        case Fruit.STRAWBERRY -> fruitWorth = 300;
                        case Fruit.ORANGE -> fruitWorth = 500;
                        case Fruit.APPLE -> fruitWorth = 700;
                        case Fruit.MELON -> fruitWorth = 1000;
                        case Fruit.GALAXIAN -> fruitWorth = 2000;
                        case Fruit.BELL -> fruitWorth = 3000;
                        case Fruit.KEY -> fruitWorth = 5000;
                    }
                    score += fruitWorth;
                    fruit.play();
                } else {
                    if (!pelletFirst) {
                        dotSound2.play();
                        pelletFirst = true;
                    } else {
                        dotSound1.play();
                        pelletFirst = false;
                    }
                    score += pelletWorth;
                    pelletsEaten++;
                }
                eaten = true;
                giveLives();
                messages.add("Your score is:" + str(score));
                increaseHighScore();
                if (pelletsEaten >= pellet.length - 1 && !lostLife) {
                    level++;
                    determineFruitType();
                    durationStart = millis();
                    duration = 2000 + millis();
                }
            }
        }

        private void draw() {
            if (!eaten) {
                noStroke();
                if (isFruit) {
                    switch (fruitType) {
                        case Fruit.STRAWBERRY -> image(strawberry, x, y, CELLWIDTH, CELLWIDTH);
                        case Fruit.ORANGE -> image(orange, x, y, CELLWIDTH, CELLWIDTH);
                        case Fruit.APPLE -> image(apple, x, y, CELLWIDTH, CELLWIDTH);
                        case Fruit.MELON -> image(melon, x, y, CELLWIDTH, CELLWIDTH);
                        case Fruit.GALAXIAN -> image(galaxian, x, y, CELLWIDTH, CELLWIDTH);
                        case Fruit.BELL -> image(bell, x, y, CELLWIDTH, CELLWIDTH);
                        case Fruit.KEY -> image(keyI, x, y, CELLWIDTH, CELLWIDTH);
                        default -> image(cherry, x, y, CELLWIDTH, CELLWIDTH);
                    }
                } else {
                    noStroke();
                    fill(255, 150, 0);
                    ellipse(x, y, HALF_CELLWIDTH - 1, HALF_CELLWIDTH - 1);
                }
            }
        }
    }

    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Pacman~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    final class Pacman {
        static final int size = CELLWIDTH - 1;
        //private static final int speed = Settings.pacmanSpeed;
        int x = HALF_CELLWIDTH + CELLWIDTH;
        int y = HALF_CELLWIDTH + CELLWIDTH;
        private boolean stopped = true;
        private Dir nextDir = Dir.STOPPED;
        private Dir dir = Dir.STOPPED;
        private Dir lastDir = Dir.STOPPED;

        @SuppressWarnings("IntegerDivisionInFloatingPointContext")
        private void show(int mouthSize) {
            float mouthOpenTop, mouthOpenBottom;
            if (stopped && Settings.startsAsCircle) {
                mouthSize = 0;
                if (playStartSound) {
                    startSound.play();
                    playStartSound = false;
                }
            }
            fill(255, 255, 0);
            translate(x, y);
            switch (lastDir) {
                case Dir.UP -> rotate(PI + HALF_PI);
                case Dir.DOWN -> rotate(HALF_PI);
                case Dir.LEFT -> rotate(PI);
            }
            mouthOpenTop = map(mouthSize, 0, 60, 0, 0.52f);
            mouthOpenBottom = map(mouthSize, 0, 60, TWO_PI, 5.76f);

            arc(0, 0, (CELLWIDTH / 16) * 15, (CELLWIDTH / 16) * 15, mouthOpenTop, mouthOpenBottom);

            resetMatrix();
        }

        private void update() {
            if (Settings.useClassicHitbox) {
                float offsetX = 0.2f;
                float offsetY = 0.1f;
                float a = 3;
                float b = 1;
                switch (dir) {
                    case Dir.UP -> offsetY += (CELLWIDTH / a) + b;
                    case Dir.DOWN -> offsetY -= (CELLWIDTH / a) + b;
                    case Dir.RIGHT -> offsetX -= (CELLWIDTH / a) + b;
                    case Dir.LEFT -> offsetX += (CELLWIDTH / a) + b;
                }
                coordsX = round((x + offsetX) / CELLWIDTH + 0.5f) - 1;
                coordsY = round((y + offsetY) / CELLWIDTH + 0.5f) - 1;
            } else {
                coordsX = Math.round(((float) (x / CELLWIDTH)) + 0.5f) - 1;
                coordsY = Math.round(((float) (y / CELLWIDTH)) + 0.5f) - 1;
            }
            if (pelletsEaten >= pellet.length - 1) {
                for (Pellet value : pellet) {
                    value.update();
                }
                coordsX = 1;
                coordsY = 1;
                x = CELLWIDTH + HALF_CELLWIDTH;
                y = CELLWIDTH + HALF_CELLWIDTH;
                dir = Dir.STOPPED;
                nextDir = Dir.STOPPED;
                pelletsEaten = 0;
            }

            switch (nextDir) {
                case Dir.UP -> {
                    if (cells[coordsX][coordsY - 1].open) {
                        dir = nextDir;
                        x = coordsX * CELLWIDTH + (HALF_CELLWIDTH);
                    }
                }
                case Dir.DOWN -> {
                    if (cells[coordsX][coordsY + 1].open) {
                        dir = nextDir;
                        x = coordsX * CELLWIDTH + (HALF_CELLWIDTH);
                    }
                }
                case Dir.RIGHT -> {
                    if (cells[coordsX + 1][coordsY].open) {
                        dir = nextDir;
                        y = coordsY * CELLWIDTH + (HALF_CELLWIDTH);
                    }
                }
                case Dir.LEFT -> {
                    if (cells[coordsX - 1][coordsY].open) {
                        dir = nextDir;
                        y = coordsY * CELLWIDTH + (HALF_CELLWIDTH);
                    }
                }
            }
            if (Settings.useClassicHitbox) {
                switch (dir) {
                    case Dir.UP -> {
                        if (cells[parseInt(coordsX)][parseInt(coordsY) - 1].open) {
                            y -= Settings.pacmanSpeed;
                            stopped = false;
                            if (x < coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                                x++;
                            }
                            if (x > coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                                x--;
                            }
                            lastDir = Dir.UP;
                        } else {
                            dir = nextDir;
                            nextDir = Dir.STOPPED;
                        }
                    }
                    case Dir.DOWN -> {
                        if (cells[parseInt(coordsX)][parseInt(coordsY) + 1].open) {
                            y += Settings.pacmanSpeed;
                            stopped = false;
                            if (x < coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                                x++;
                            }
                            if (x > coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                                x--;
                            }
                            lastDir = Dir.DOWN;
                        } else {
                            dir = nextDir;
                            nextDir = Dir.STOPPED;
                        }
                    }
                    case Dir.RIGHT -> {
                        if (cells[parseInt(coordsX) + 1][parseInt(coordsY)].open) {
                            x += Settings.pacmanSpeed;
                            stopped = false;
                            if (y < coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                                y++;
                            }
                            if (y > coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                                y--;
                            }
                            lastDir = Dir.RIGHT;
                        } else {
                            dir = nextDir;
                            nextDir = Dir.STOPPED;
                        }
                    }
                    case Dir.LEFT -> {
                        if (cells[parseInt(coordsX) - 1][parseInt(coordsY)].open) {
                            x -= Settings.pacmanSpeed;
                            stopped = false;
                            if (y < coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                                y++;
                            }
                            if (y > coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                                y--;
                            }
                            lastDir = Dir.LEFT;
                        } else {
                            dir = nextDir;
                            nextDir = Dir.STOPPED;
                        }
                    }
                    case Dir.STOPPED -> {
                        if (x < coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                            x++;
                        }
                        if (x > coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                            x--;
                        }
                        if (y < coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                            y++;
                        }
                        if (y > coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                            y--;
                        }
                    }
                }

            } else {


                int stopBuffer = 2;
                switch (dir) {
                    case Dir.UP -> {
                        if (cells[coordsX][coordsY - 1].open) {
                            y -= Settings.pacmanSpeed;
                            stopped = false;
                            if (x < coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                                x += Settings.pacmanSpeed;
                            }
                            if (x > coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                                x -= Settings.pacmanSpeed;
                            }
                            lastDir = Dir.UP;
                        } else {
                            if (y <= (coordsY * CELLWIDTH + (HALF_CELLWIDTH)) + stopBuffer) {
                                dir = nextDir;
                                nextDir = Dir.STOPPED;
                            } else {
                                y -= Settings.pacmanSpeed;
                            }
                        }
                    }
                    case Dir.DOWN -> {
                        if (cells[coordsX][coordsY + 1].open) {
                            y += Settings.pacmanSpeed;
                            stopped = false;
                            if (x < coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                                x += Settings.pacmanSpeed;
                            }
                            if (x > coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                                x -= Settings.pacmanSpeed;
                            }
                            lastDir = Dir.DOWN;
                        } else {
                            if (y >= (coordsY * CELLWIDTH + (HALF_CELLWIDTH)) - stopBuffer) {
                                dir = nextDir;
                                nextDir = Dir.STOPPED;
                            } else {
                                y += Settings.pacmanSpeed;
                            }
                        }
                    }
                    case Dir.RIGHT -> {
                        if (cells[coordsX + 1][coordsY].open) {
                            x += Settings.pacmanSpeed;
                            stopped = false;
                            if (y < coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                                y += Settings.pacmanSpeed;
                            }
                            if (y > coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                                y -= Settings.pacmanSpeed;
                            }
                            lastDir = Dir.RIGHT;
                        } else {
                            if (x >= (coordsX * CELLWIDTH + (HALF_CELLWIDTH)) - stopBuffer) {
                                dir = nextDir;
                                nextDir = Dir.STOPPED;
                            } else {
                                x += Settings.pacmanSpeed;
                            }
                        }
                    }
                    case Dir.LEFT -> {
                        if (cells[coordsX - 1][coordsY].open) {
                            x -= Settings.pacmanSpeed;
                            stopped = false;
                            if (y < coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                                y += Settings.pacmanSpeed;
                            }
                            if (y > coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                                y -= Settings.pacmanSpeed;
                            }
                            lastDir = Dir.LEFT;
                        } else {
                            if (x <= (coordsX * CELLWIDTH + (HALF_CELLWIDTH)) + stopBuffer) {
                                dir = nextDir;
                                nextDir = Dir.STOPPED;
                            } else {
                                x -= Settings.pacmanSpeed;
                            }
                        }
                    }
                    case Dir.STOPPED -> {
                        if (x < coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                            x += Settings.pacmanSpeed;
                        }
                        if (x > coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                            x -= Settings.pacmanSpeed;
                        }
                        if (y < coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                            y += Settings.pacmanSpeed;
                        }
                        if (y > coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                            y -= Settings.pacmanSpeed;
                        }
                    }
                }
            }

            if (x > 400) {
                x = CELLWIDTH + size / 2;
            }
            if (y > 400) {
                y = CELLWIDTH + size / 2;
            }
            coordsX = Math.round((float) (x / CELLWIDTH) + 0.5f) - 1;
            coordsY = Math.round((float) (y / CELLWIDTH) + 0.5f) - 1;
        }

        private void up() {
            coordsX = Math.round(((float) x / CELLWIDTH) + 0.5f) - 1;
            coordsY = Math.round((float) (y / CELLWIDTH) + 0.5f) - 1;
            if (cells[coordsX][coordsY - 1].open) {
                dir = Dir.UP;
                nextDir = Dir.UP;
                if (x < coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                    x += Settings.pacmanSpeed;
                }
                if (x > coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                    x -= Settings.pacmanSpeed;
                }
            } else {
                nextDir = Dir.UP;
            }

            // }
        }

        private void down() {
            coordsX = Math.round(((float) (x / CELLWIDTH)) + 0.5f) - 1;
            coordsY = Math.round((float) (y / CELLWIDTH) + 0.5f) - 1;
            if (cells[coordsX][coordsY + 1].open) {
                dir = Dir.DOWN;
                nextDir = Dir.DOWN;
                if (x < coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                    x += Settings.pacmanSpeed;
                }
                if (x > coordsX * CELLWIDTH + (HALF_CELLWIDTH)) {
                    x -= Settings.pacmanSpeed;
                }
            } else {
                nextDir = Dir.DOWN;
            }


        }

        private void right() {
            coordsX = Math.round((float) (x / CELLWIDTH) + 0.5f) - 1;
            coordsY = Math.round((float) (y / CELLWIDTH) + 0.5f) - 1;
            if (cells[coordsX + 1][coordsY].open) {
                dir = Dir.RIGHT;
                nextDir = Dir.RIGHT;
                if (y < coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                    y += Settings.pacmanSpeed;
                }
                if (y > coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                    y -= Settings.pacmanSpeed;
                }
            } else {
                nextDir = Dir.RIGHT;
            }


        }

        private void left() {
            coordsX = Math.round(((float) (x / CELLWIDTH)) + 0.5f) - 1;
            coordsY = Math.round(((float) (y / CELLWIDTH)) + 0.5f) - 1;
            if (cells[coordsX - 1][coordsY].open) {
                dir = Dir.LEFT;
                nextDir = Dir.LEFT;
                if (y < coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                    y += Settings.pacmanSpeed;
                }
                if (y > coordsY * CELLWIDTH + (HALF_CELLWIDTH)) {
                    y -= Settings.pacmanSpeed;
                }
            } else {
                nextDir = Dir.LEFT;
            }

        }


        private void stop() {
            dir = Dir.STOPPED;
            stopped = false;
            nextDir = Dir.STOPPED;
        }
    }

    private final class Pixel {
        private static int size;
        private final int colourCode;
        private final int x;
        private final int y;
        private int colour;

        private Pixel(int colourCode1, int x1, int y1) {
            colourCode = colourCode1;
            size = 2;
            x = x1;
            y = y1;
        }

        private void colourInit() {
            switch (colourCode) {
                case 0 -> colour = color(255, 0);
                case 2, 3 -> colour = color(255);
                default -> colour = color(255, 0, 0);
            }
        }


        private void draw(int gColour) {
            if (colourCode == 1) {
                colour = gColour;
            }
            rectMode(CENTER);
            fill(colour);
            rect(x, y, size, size);
            rectMode(CORNER);
        }
    }
}
